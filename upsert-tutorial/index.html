<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map.prototype.upsert Tutorial</title>
    <link rel="stylesheet" href="style.css"> <!-- Link to CSS file for styling -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
</head>
<body>
    <div class="container">
        <!-- Sidebar for Table of Contents -->
        <aside class="sidebar">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#ecmascript">ECMAScript®</a></li>
                <li><a href="#introduction">Introduction</a></li>
                <li><a href="#whats-covered">What’s Covered in This Tutorial?</a></li>
                <li><a href="#proposal-overview">The Map.prototype.upsert Proposal</a></li>
                <li><a href="#installation">Installing Mozilla Unified</a></li>
                <li><a href="#specification">How to Read the ECMA-262 Language Specification</a></li>
                <li><a href="#searchfox">Using Searchfox</a></li>
                <li><a href="#implementation">Implementation</a></li>
                <li><a href="#issues">Issues with the Original Proposal</a></li>
                <li><a href="#new-proposal">Explaining the New Proposal</a></li>
                <li><a href="#implementing-new-proposal">Implementing the New Proposal</a></li>
                <li><a href="#ecmarkup">Writing the Specification in Ecmarkup</a></li>
                <li><a href="#optimization">Optimization</a></li>
                <li><a href="#testing">Testing with Test262</a></li>
            </ul>
        </aside>

        <!-- Main Content Area -->
        <div class="content">
            <header>
                <h1>Map.prototype.upsert Tutorial</h1>
                <p>Welcome to this detailed tutorial on how to implement and understand the Map.prototype.upsert proposal in JavaScript™.</p>
                <a href="initial-emplace-spec/Map.prototype.emplace.html">Here is the original specification!</a>
                <a href="key-value-callback-spec/Map.prototype.getOrInsert.html">Here is the new specification!</a>
            </header>

            <main>
                <!-- ECMAScript® Section (non-collapsible) -->
                <section id="ecmascript">
                    <h2>ECMAScript®</h2>
                    <p>
                        JavaScript™ is standardized by ECMAScript® and specified in the 
                        <a href="https://ecma-international.org/publications-and-standards/standards/ecma-262/" target="_blank">
                            ECMA-262 language specification
                        </a>, 
                        which is maintained by Ecma International through the 
                        <a href="https://tc39.es/" target="_blank">TC39 committee</a>. 
                        ECMAScript® defines the core features of the language, providing a standard that ensures consistency across different JavaScript™ engines. 
                        Major engines like 
                        <a href="https://v8.dev/" target="_blank">V8</a> (used in Chrome and Node.js), 
                        <a href="https://developer.apple.com/documentation/javascriptcore" target="_blank">JavaScriptCore</a> (Safari), 
                        and 
                        <a href="https://spidermonkey.dev/" target="_blank">SpiderMonkey</a> (Firefox) 
                        implement these specifications, allowing developers to write code that behaves similarly across different environments.
                    </p>
                    <p>
                        SpiderMonkey, the engine developed by Mozilla, powers JavaScript™ execution in Firefox and supports the development of new language features. 
                        This tutorial focuses on working within SpiderMonkey to implement and test a new JavaScript™ proposal, providing insight into both the ECMAScript® 
                        standardization process and the inner workings of a JavaScript™ engine.
                    </p>
                </section>

                <!-- Introduction Section (non-collapsible) -->
                <section id="introduction">
                    <h2>Introduction</h2>
                    <p>Welcome to this detailed tutorial on how to implement and understand the Map.prototype.upsert proposal. This guide is tailored to help both beginners and advanced developers learn how to contribute to JavaScript™ language development by implementing a new feature in SpiderMonkey, Mozilla's JavaScript™ engine. We’ll cover all the necessary steps, from downloading and setting up the development environment to writing the upsert method and testing it with the official test suite, Test262.</p>
                    <p>We'll start with an introduction to the Map.prototype.upsert proposal, highlighting its benefits for developers. From there, you'll be guided through setting up the development environment using Mozilla's SpiderMonkey JavaScript™ engine. You'll then implement the upsert method using both self-hosted JavaScript™ and (a little bit of) C++, ensuring alignment with the ECMAScript® specification.</p>
                    <p>By the end of this tutorial, you'll have implemented a fully functional upsert method and gained valuable insight into the process of designing, testing, and standardizing JavaScript™ features.</p>
                </section>

                <!-- What's Covered Section (non-collapsible) -->
                <section id="whats-covered">
                    <h2>What’s Covered in This Tutorial?</h2>
                    <ul>
                        <li>The Map.prototype.upsert Proposal: Learn what this proposal is, how it works, and why it’s beneficial for JavaScript™ developers.</li>
                        <li>Setting Up the Development Environment: How to download and build Mozilla Unified, the repository that contains SpiderMonkey.</li>
                        <li>Implementing the Proposal: Implementing the upsert method in self-hosted JavaScript™ and C++.</li>
                        <li>Debugging and Testing: How to test your implementation using Test262 and run custom scripts.</li>
                        <li>Optimizing Your Code: Learn about performance considerations and optimizations.</li>
                        <li>Contributing to the ECMAScript® Standard: Understand how to write specification-compliant code and contribute to ECMAScript®.</li>
                    </ul>
                </section>

                <!-- Collapsible Sections for Detailed Topics -->
                <section class="collapsible" id="proposal-overview">
                    <h2>The Map.prototype.upsert Proposal</h2>
                    <div class="content-body">
                        <p>[Details on the Map.prototype.upsert proposal go here]</p>
                    </div>
                </section>

                <section class="collapsible" id="installation">
                    <h2>Installing Mozilla Unified</h2>
                    <div class="content-body">
                        <p>[Installation steps go here]</p>
                    </div>
                </section>

                <section class="collapsible" id="specification">
                    <h2>How to Read the ECMA-262 Language Specification</h2>
                    <div class="content-body">
                        <p>[Specification reading guide goes here]</p>
                    </div>
                </section>

                <section class="collapsible" id="searchfox">
                    <h2>Using Searchfox</h2>
                    <div class="content-body">
                        <p>  <a href="https://searchfox.org/" target="_blank">Searchfox</a> is a helpful tool. Searchfox provides an indexed view of the source code, allowing developers to efficiently search for specific files, functions, or keywords. For instance, you can trace the implementation of existing JavaScript™ features, see how certain functions interact with SpiderMonkey’s internal data structures, or find how built-in JavaScript™ objects like <code>Map</code> are handled. SearchFox helps you navigate a seemingly endless and confusing codebase.</p>
                        <p>  When Implementing the <code>upsert</code> proposal, you will find that looking at existing implementations of similar functionality is often a good starting point. Combine the ECMA-262 Specification with Searchfox and look at existing code.</p>
                        <p>  Example workflow:</p>
                        <ol>
                            <li><em>Some line from the specification</em>.</li>
                            <li>Find some other function with the same or similar spec line in the ECMA-262 specification.</li>
                            <li>Look up the function in Searchfox.</li>
                            <li>Borrow from the other function.</li>
                        </ol>
                    </div>
                </section>

                <section class="collapsible" id="implementation">
                    <h2>Implementation</h2>
                    <div class="content-body">
                        <p>[Implementation guide goes here]</p>
                    </div>
                </section>

                <section class="collapsible" id="issues">
                    <h2>Issues with the Original Proposal</h2>
                    <div class="content-body">
                        <p>[Explanation of issues with the original proposal goes here]</p>
                    </div>
                </section>

                <section class="collapsible" id="new-proposal">
                    <h2>Explaining the New Proposal</h2>
                    <div class="content-body">
                        <p>The new <a href="https://github.com/tc39/proposal-upsert" target="_blank">proposal</a> presents the idea of implementing two different versions. </p>
                        <p>  (1) Takes the arguments <code>key</code> and <code>value</code>. </p>
                        <p>  (2) Takes the arguments <code>key</code> and <code>callbackfn</code></p>
                        <p>  Both the respective versions with <code>value</code> and <code>callbackfn</code> serves the same principle as a <code>get</code> or <code>insert</code> if missing method on the <code>MapObject</code>. For the remainder of this tutorial we will focus on the <code>upsert(key, value)</code> version.</p>
                        <p>   <strong>What is the motivation for a new proposal?</strong>
                            A common problem when using a <code>Map</code> is how to handle doing a <code>Map</code> entry when you&#39;re not sure if the <code>key</code> already exists in the <code>Map</code>. This can be handled by first checking if the <code>key</code> is present, and then inserting or updating depending upon the result, but this is both inconvenient for the developer, and less than optimal, because it requires multiple lookups in the <code>Map</code> that could otherwise be handled in a single call.</p>
                        <p>   <strong>What is the solution?</strong>
                            A method that will check whether the given <code>key</code> already exists in the <code>Map</code>. If the <code>key</code> already exists, the <code>value</code> associated with the <code>key</code> is returned. Otherwise the new <code>key-value</code> pair is inserted in to the <code>Map</code>, before returning the newly input <code>value</code>.</p>
                        <p>   <strong>Simple use of &quot;new&quot; upsert:</strong></p>
                        <pre><code class="language-js"> // Currently
 let prefs = new getUserPrefs();
 if (prefs.has(&quot;useDarkmode&quot;)) {
     let darkMode = prefs.get(&quot;useDarkmode&quot;);
 }
 else {
     prefs.set(&quot;useDarkmode&quot;, true);
     darkMode = true; //Default value
 }

 // Using upsert
 let prefs = new getUserPrefs();
     prefs.upsert(&quot;useDarkmode&quot;, true); // Default to true
</code></pre>
                        <p>By using <code>upsert</code>, default values can be applied at different times, with the assurance that later defaults will not overwrite an existing <code>value</code>. This is obviously because the <code>key</code> already exists and will <code>return</code> the existing <code>key</code> instead of inserting or overwriting.</p>
                        <details>
                            <summary>
                                Similar functionality in Python
                            </summary>
                            As mentioned earlier in this tutorial, there are similar functionalities in other languages such as Python and its setdefault method. In our case we use upsert on Map's. The setdefault method is used on dictionaries, lets use a similar code example:

                            <pre><code class="language-python"># Without setdefault
prefs = {}
if &quot;useDarkmode&quot; not in prefs :
  prefs[&quot;useDarkmode&quot;] = True # Default value

dark_mode = prefs[&quot;useDarkmode&quot;]
</code></pre>
                            <pre><code class="language-python"># Using setdefault
prefs = {}
prefs.setdefault(&quot;useDarkmode&quot;, True)
</code></pre>
                        </details>

                        <p>To implement the updated proposal, we first need to adapt the specification. </p>
                        <h3 id="a-draft-of-the-new-specification-for-the-proposal">A Draft of The New Specification For The Proposal.</h3>
                        <p>The new specification now looks like this. It draws similarities from the old specification and adapts to the newly specified behaviour we seek in the <code>Map.prototype.upsert</code> method.</p>
                        <pre><code class="language-lua">1. Let M be the this value.
2. Perform ? RequireInternalSlot(M, [[MapData]]).
3. Let entries be the List that is M.[[MapData]].
4. For each Record { [[Key]], [[Value]] } e that is an element of entries, do
  4a. If e.[[Key]] is not empty and SameValueZero(e.[[Key]], key) is true, return e.[[Value]].
5. Set e.[[Value]] to value.
6. Return e.[[Value]].
</code></pre>
                        <p>  The next section will be based on this draft of the new specification. Later in the tutorial we will look into how we can write the specification in ecmarkup.</p>
                        <p>  An html version of the specification can be found <a href="https://bldl.github.io/upsert-tutorial/key-value-callback-spec/Map.prototype.getOrInsert.html" target="_blank">here.</a></p>

                    </div>
                </section>

                <section class="collapsible" id="implementing-new-proposal">
                    <h2>Implementing the New Proposal</h2>
                    <div class="content-body">
                        <p>In this section, we will adapt our implementation to match the updated proposal specification. Fortunately, some of the logic from the previous implementation can be reused. Our goal here is to keep the code clean and efficient by making only the necessary adjustments.</p>
                        <h3 id="step-1-4---the-logic-remains-the-same">Step 1 to 4  -  The logic remains the same</h3>
                        <p>  The first four steps remain unchanged from the original proposal.</p>
                        <p>  <strong>The Specification States:</strong></p>
                        <pre><code>1. Let M be the this value.
2. Perform ? RequireInternalSlot(M, [[MapData]]).
3. Let entries be the List that is M.[[MapData]].
4. For each Record { [[Key]], [[Value]] } e that is an element of entries, do
</code></pre>
                        <p>  These lines are similar to the previous proposal specification and they remain seemingly unchanged. Only a few altercations are introduced. We need to update the argument <code>handler</code> to <code>value</code>.</p>
                        <details>
                            <summary>Solution</summary>

                            <pre><code class="language-js">
function MapUpsert(key, value) {
  var M = this;

  if (!IsObject(M) || (M = GuardToMapObject(M)) === null) {
    return callFunction(
      CallMapMethodIfWrapped,
      this,
      key,
      value,
      &quot;MapUpsert&quot;
    );
  }

  var entries = callFunction(std_Map_entries, M);

  for (var e of allowContentIter(entries)) {
    var eKey = e[0];
    var eValue = e[1];

    //...
  }
}
</code></pre>
                            <p>We are now ready to proceed and update the logic of the function.</p>
                        </details>

                        <h3 id="step-4a---if-the-key-exists-return-the-value">Step 4a - If the key exists, return the value</h3>
                        <p>  In this step, we implement the condition to handle the case when the <code>key</code> already exists in the <code>Map</code>.</p>
                        <p>  <strong>Specification Line:</strong></p>
                        <pre><code>4a. If e.[[Key]] is not empty and SameValueZero(e.[[Key]], key) is true, return e.[[Value]].
</code></pre>
                        <p>In the updated logic, we are only concerned with returning the existing <code>value</code> if the <code>key</code> is found, rather than handling updates. This is a streamlined approach that differs from our previous implementation.</p>
                        <p>Use the built-in <code>std_Map_get</code> function to <code>return</code> the existing <code>value</code>.</p>
                        <details>
                            <summary>Solution</summary>

                            <pre><code class="language-js">
function MapUpsert(key, value) {
  var M = this;

  if (!IsObject(M) || (M = GuardToMapObject(M)) === null) {
    return callFunction(
      CallMapMethodIfWrapped,
      this,
      key,
      value,
      &quot;MapUpsert&quot;
    );
  }

  var entries = callFunction(std_Map_entries, M);

  for (var e of allowContentIter(entries)) {
    var eKey = e[0];
    var eValue = e[1];

    if (SameValueZero(eKey, key)) {
      return callFunction(std_Map_get, M, key);
    }
  }
}
</code></pre>
                            <p>With this code in place, our <code>MapUpsert</code> function will <code>return</code> the existing <code>value</code> if the <code>key</code> is found in the <code>Map</code>. If the <code>key</code> does not exist, the function will continue to the next steps, where we will handle inserting a new entry.</p>
                        </details>

                        <h3 id="step-5--6---insert-the-new-key-value-pair">Step 5 &amp; 6 - Insert the new key value pair</h3>
                        <p>  Now, we address the scenario where the <code>key</code> does not already exist in the <code>Map</code>. If the specified <code>key</code> is not found in the previous iteration step, <code>insert</code> the new <code>value</code> and <code>return</code> it.</p>
                        <p>  <strong>The Specification States:</strong></p>
                        <pre><code>5. Set e.[[Value]] to value.
6. Return e.[[Value]].
</code></pre>
                        <p>  In this case, we will add the new <code>key</code>-<code>value</code> pair to the <code>Map</code> and then <code>return</code> the <code>value</code>. We can achieve this by using the built-in <code>Map::set</code> method, which allows us to add entries directly and efficiently.</p>
                        <details>
                            <summary>Solution</summary>

                            <pre><code class="language-js">function MapUpsert(key, value) {
  var M = this;

  if (!IsObject(M) || (M = GuardToMapObject(M)) === null) {
    return callFunction(
      CallMapMethodIfWrapped,
      this,
      key,
      value,
      &quot;MapUpsert&quot;
    );
  }

  var entries = callFunction(std_Map_entries, M);

  for (var e of allowContentIter(entries)) {
    var eKey = e[0];
    var eValue = e[1];

    if (SameValueZero(eKey, key)) {
      return callFunction(std_Map_get, M, key);
    }
  }

  callFunction(std_Map_set, M, key, value);

  return value;
}
</code></pre>
                        </details>

                        <p>With these fairly simple steps our new implementation is now more streamlined with a simpler and more attractive API.</p>

                    </div>
                </section>

                <section class="collapsible" id="ecmarkup">
                    <h2>Writing the Specification in Ecmarkup</h2>
                    <div class="content-body">
                        <p>In this section, we will cover how to install and use Ecmarkup to write specifications for proposals.
                            Ecmarkup is a markup language that is designed for technical specifications.
                            This allows the authors to visualize and format complex algorithms, clauses and terms in a way that is both readable and structured.
                            Regarding JavaScript-proposals, Ecmarkup provides a solid framework to document new algorithms or implementations so they align with the ECMAScript®-standards. </p>
                        <p>  We will start with setting up the necessary tools to be able to use Ecmarkup, such as Node.js and Ecmarkup itself.
                            Furthermore, we will check out how to format specification using Ecmarkup before guiding you through how to build your specification into an HTML document. </p>
                        <ul>
                            <li><p><strong>Installing Node.js and Node Package Manager</strong></p>
                                <div class="tab-container">
                                    <div class="tabs">
                                        <button class="tab-button active" data-tab="ecmarkup-windows-tab">Windows</button>
                                        <button class="tab-button" data-tab="ecmarkup-mac-tab">Mac</button>
                                        <button class="tab-button" data-tab="ecmarkup-linux-tab">Linux</button>
                                    </div>
                                    <div class="tab-content active" id="ecmarkup-windows-tab">
                                        <ol>
                                            <li><p>First go to Node.js official website (<a href="https://nodejs.org/en">https://nodejs.org/en</a>), and download the Windows Installer (recommended version).</p>
                                            </li>
                                            <li><p>Run the installer and follow the instructions (make sure to check the box that says &quot;Automatically install necessary tools&quot;).</p>
                                            </li>
                                            <li><p>Verify installation by opening Command Prompt and typing:</p>
                                            </li>
                                        </ol>
                                        <pre><code class="language-sh">node -v
npm -v
</code></pre>
                                        <p>This should return the versions of Node.js and npm.</p>
                                    </div>
                                    <div class="tab-content" id="ecmarkup-mac-tab">
                                        <ol>
                                            <li>Open Terminal</li>
                                            <li>Install Node.js via Homebrew by running the following command:</li>
                                        </ol>
                                        <pre><code class="language-sh">brew install node
</code></pre>
                                        <ol start="3">
                                            <li>Verify installation by typing:</li>
                                        </ol>
                                        <pre><code class="language-sh">node -v
npm -v
</code></pre>
                                    </div>
                                    <div class="tab-content" id="ecmarkup-linux-tab">
                                        <ol>
                                            <li>Open Terminal</li>
                                            <li>Update your package list:</li>
                                        </ol>
                                        <pre><code class="language-sh">sudo apt update
</code></pre>
                                        <ol start="3">
                                            <li>Install Node.js by running:</li>
                                        </ol>
                                        <pre><code class="language-sh">sudo apt install node.js spm
</code></pre>
                                        <ol start="4">
                                            <li>Verify the installation:</li>
                                        </ol>
                                        <pre><code class="language-sh">node -v
npm -v
</code></pre>
                                    </div>
                                </div>

                            </li>
                            <li><p><strong>Installing <a href="https://tc39.es/ecmarkup/" target="_blank">Ecmarkup</a></strong></p>
                                <ul>
                                    <li>Windows/Mac/Linux<ol>
                                        <li>Open Command Prompt (Windows) or Terminal (Mac/Linux)</li>
                                        <li>Run the following command to install Ecmarkup globally:</li>
                                    </ol>
                                        <pre><code class="language-sh">npm install -g ecmarkup
</code></pre>
                                        <ol start="3">
                                            <li>Verify that Ecmarkup has been installed by typing:</li>
                                        </ol>
                                        <pre><code class="language-sh">ecmarkup --version
</code></pre>
                                        <p>You have now installed Ecmarkup.</p>
                                    </li>
                                </ul>
                            </li>
                            <li><p><strong>How to write ecmarkup</strong></p>
                                <p>Ecmarkup is a markup language used for writing technical specifications. It has a syntax similar to <code>HTML</code>, making it intuitive for those familiar with web development. Here&#39;s a simple example of what an algorithm in a <code>.emu</code> file looks like (<code>.emu</code> is the file ending of an ecmarkup file):</p>
                                <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;meta charset=&quot;utf8&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css&quot;&gt;
&lt;script src=&quot;./spec.js&quot;&gt;&lt;/script&gt;
&lt;pre class=&quot;metadata&quot;&gt;
title: Your Document Title
stage: The proposals stage
contributors: Your name
&lt;/pre&gt;

&lt;emu-clause id=&quot;sec-greater-than-five&quot;&gt;
  &lt;h1&gt;greaterThanFive(_value_)&lt;/h1&gt;
  &lt;p&gt;When the greaterThanFive method is called, the following steps are taken:&lt;/p&gt;
  &lt;emu-alg&gt;
    1. Let _x_ be _value_.
    1. If Type(_x_) is not Number, throw a *TypeError* exception.
    1. If _x_ is NaN, throw a *RangeError* exception.
    1. If _x_ is less than 0, return *false*.
    1. If _x_ is greater than 5, return *true*.
    1. Else:
      1. Return *false*.
  &lt;/emu-alg&gt;
&lt;/emu-clause&gt;
</code></pre>
                                <p><strong>Note:</strong> This is just an example of how an Ecmarkup file should be structured. The algorithm itself is illustrative and not a real-world example.</p>
                            </li>
                            <li><p><strong>How to format spec text using Ecmarkup</strong></p>
                                <p>Formatting spec text using Ecmarkup involves understanding the differences between what each reperesents. ECMAScript® is a scripting language specification, while Ecmarkup is a specialized markup language used to write and format <strong>specification documents</strong> for ECMAScript® and other web standards.</p>
                                <ol>
                                    <li><p><strong>Understanding why we need Ecmarkup</strong></p>
                                        <p>Ecmarkup combines HTML-like tags with specific syntactic constructs to write formal specifications. If you visit the <a href="https://tc39.es/ecma262/" target="_blank">TC39 official website</a> for ECMA-262, you can read ECMAScript® with hyperlinks to used terms, algorithms, and syntax definitions, allowing for easy navigation between different sections and components of the specification. These specifications are made with Ecmarkup.</p>
                                    </li>
                                    <li><p><strong>Basic translation steps</strong></p>
                                        <ul>
                                            <li><code>&lt;emu-alg&gt;</code>: Defines an algorithm.</li>
                                            <li><code>&lt;emu-clause&gt;</code>: Defines a clause/section in the specification.</li>
                                            <li>Underscores are used to refer to variables (<code>_varname_</code>).</li>
                                            <li><code>&lt;emu-xref&gt;</code>: Link to other sections, clauses or algorithms within the specification.</li>
                                            <li><code>*someBoldText*</code>: Make bold text with <code>*</code>.</li>
                                            <li>Use double square brackets (<code>[[...]]</code>) when documenting or referring to the internal, hidden mechanisms of objects that are not directly accessible in the JavaScript™ language but are crucial for the implementation and behavior of the object.</li>
                                        </ul>
                                    </li>
                                </ol>
                            </li>
                            <li><p>The function <code>upsert(key, callbackfn)</code> in ecmarkup (can also be found under the spec-folder in this proposal)</p>
                                <pre><code class="language-html">  &lt;!DOCTYPE html&gt;
  &lt;meta charset=&quot;utf8&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css&quot;&gt;
  &lt;script src=&quot;./spec.js&quot;&gt;&lt;/script&gt;
  &lt;pre class=&quot;metadata&quot;&gt;
  title: Map.prototype.upsert
  stage: 2
  contributors: Lauritz Angeltveit
  &lt;/pre&gt;

  &lt;emu-clause id=&quot;sec-map.prototype.upsert&quot;&gt;
    &lt;h1&gt;Map.prototype.upsert ( _key_, _callbackfn_ )&lt;/h1&gt;
    &lt;p&gt;When the upsert method is called the following steps are taken:&lt;/p&gt;
    &lt;emu-alg&gt;
      1. Let _M_ be the *this* value.
      1. Perform ? RequireInternalSlot(_M_, [[MapData]]).
      1. If IsCallable(_callbackfn_) is false, throw a *TypeError* exception.
      1. For each Record { [[Key]], [[Value]] } _e_ that is an element of _M_.[[MapData]], do:
        1. If _e_.[[Key]] is not empty and SameValueZero(_e_.[[Key]], _key_) is *true*, return _e_.[[Value]].
      1. Let _inserted_ be ? Call(_callbackfn_, _key_).
      1. Set _e_.[[Value]] to _inserted_.
      1. Return _e_.[[Value]].
    &lt;/emu-alg&gt;
  &lt;/emu-clause&gt;
</code></pre>
                            </li>
                            <li><p><strong>Building the spec</strong></p>
                                <p>To build the spec, use the following command:</p>
                                <pre><code class="language-sh">  ecmarkup spec.emu out.html
</code></pre>
                                <p>In this command:</p>
                                <ul>
                                    <li><code>spec.emu</code> is the source file where you have written your specification using Ecmarkup.</li>
                                    <li><code>out.html</code> is the output file, which is a runnable HTML document.
                                        To verify that your specification has been built correctly, simply drag-and-drop the <code>out.html</code> file into a web browser.</li>
                                </ul>
                            </li>
                        </ul>

                    </div>
                </section>

                <section class="collapsible" id="optimization">
                    <h2>Optimization</h2>
                    <div class="content-body">
                        <p>A proposal goes through several <a href="https://www.proposals.es/stages" target="_blank">stages</a> before it becomes a part of the ECMAScript® language.
                            Every new feature introduces complexity, which can affect the performance of the SpiderMonkey engine.
                            Therefore optimization becomes crucial when designing and implementing these features.
                            In our case there is especially one line which could use some optimization:</p>
                        <pre><code>4. For each Record { [[Key]], [[Value]] } e that is an element of entries, do</code></pre>
                        <p>  As of right now it is implemented like this:</p>
                        <pre><code class="language-js">for (var e of allowContentIter(entries)) {
  var eKey = e[0];
  var eValue = e[1];
  //...
}
</code></pre>
                        <p>  The worst case for this is that is loops through the entire <code>entries</code>. The result is a runtime of <strong><code>O(n)</code></strong> where <code>n</code> is the size of the <code>Map</code>.
                            This is rather slow, considering a lookup in maps should be <strong><code>~O(1)</code></strong>, given an efficient <code>HashTable</code> implementation.
                            Therefore, we decided to try optimizing this line.</p>
                        <p>  <strong>Demonstration: Create a new file; Runtime.js with the code below and run the script with <code>./mach build</code> and <code>./mach run Runtime.js</code></strong></p>
                        <details>
                            <summary>Runtime script</summary>

                            <pre><code class="language-js">  const iterations = 1000;

// Function to measure runtime of a given block of code
function measureRuntime(callback, description) {
    console.log(&quot;############################&quot;);
    console.log(description);
    const startTime = Date.now(); // Get the start time in milliseconds

    // Execute the code block (callback function)
    callback();

    const endTime = Date.now(); // Get the end time in milliseconds
    const runtime = endTime - startTime; // Calculate the runtime
    console.log(`Runtime: ${runtime} milliseconds \n`);
}

// test upsert for e record of entries
function withUpsert() {
    const m = new Map();

    var k = 0;
    while (k &lt; iterations) {
        m.upsert(k, &quot;val&quot;);
        k++;
    }
}

//test without upsert
function withoutUpsert() {
    const m = new Map();

    var k = 0;
    while (k &lt; iterations) {
        if (m.has(k)) {
            m.get(k);
        } else {
            m.set(k, &quot;val&quot;);
        }
        k++;
    }
}

console.log(&quot;Starting tests...&quot;);
measureRuntime(withUpsert, &quot;Test upsert for &quot; + iterations + &quot; iterations&quot;);
measureRuntime(withoutUpsert, &quot;Test without upsert for &quot; + iterations + &quot; iterations&quot;);
</code></pre>
                        </details>


                        <p>  One solution we had, was to check if the entry was in the <code>Map</code>, by using <code>Map::has</code>.
                            The problem with this, is that this method is not currently exposed to self-hosted JavaScript™ code. The reason for this
                            is seemingly because there has not been any need for the <code>Map::has</code> method in self-hosted code previously.</p>
                        <p>  <strong>Exposing <code>std_Map_has</code> to self-hosted code</strong></p>
                        <p>  <code>Selfhosting.cpp</code></p>
                        <pre><code class="language-cpp">
  // Standard builtins used by self-hosting.
  //...
  JS_FN(&quot;std_Map_entries&quot;, MapObject::entries, 0, 0),
  JS_FN(&quot;std_Map_get&quot;, MapObject::get, 1, 0),
  JS_FN(&quot;std_Map_set&quot;, MapObject::set, 2, 0),
  //...
</code></pre>
                        <p>  We want to add this line so that we can use <code>has</code> in our optimized implementation.</p>
                        <pre><code class="language-cpp">
  JS_INLINABLE_FN(&quot;std_Map_has&quot;, MapObject::has, 1, 0, MapHas),
</code></pre>
                        <p>  Copy the line and paste it into <code>js/src/vm/Selfhosting.cpp</code>, before <code>MapObject::set</code> (to ensure consistency across files).</p>
                        <details>
                            <summary>Solution</summary>

                            <pre><code class="language-cpp">
// Standard builtins used by self-hosting.
//...
JS_FN(&quot;std_Map_entries&quot;, MapObject::entries, 0, 0),
JS_FN(&quot;std_Map_get&quot;, MapObject::get, 1, 0),
JS_INLINABLE_FN(&quot;std_Map_has&quot;, MapObject::has, 1, 0, MapHas),
JS_FN(&quot;std_Map_set&quot;, MapObject::set, 2, 0),
//...
</code></pre>
                        </details>

                        <p>  We also need to make the <code>has</code> method publicly exposed in <code>MapObject.h</code> to use it in self-hosted code.</p>
                        <p>  In <code>MapObject.h</code>, move this line from <strong>private</strong> to <strong>public</strong>.</p>
                        <pre><code class="language-cpp">[[nodiscard]] static bool has(JSContext* cx, unsigned argc, Value* vp);
</code></pre>
                        <details>
                            <summary>(This could be tricky) Let's break down the structure of the file: </summary>

                            <pre><code class="language-cpp">  class MapObject : public NativeObject {
    public:
      //...
      const ValueMap* getData() { return getTableUnchecked(); }

      [[nodiscard]] static bool get(JSContext* cx, unsigned argc, Value* vp);
      [[nodiscard]] static bool set(JSContext* cx, unsigned argc, Value* vp);
      //add has here

      //...

    private:
      //...
      [[nodiscard]] static bool size_impl(JSContext* cx, const CallArgs&amp; args);
      [[nodiscard]] static bool size(JSContext* cx, unsigned argc, Value* vp);
      [[nodiscard]] static bool get_impl(JSContext* cx, const CallArgs&amp; args);
      [[nodiscard]] static bool has_impl(JSContext* cx, const CallArgs&amp; args);
      [[nodiscard]] static bool has(JSContext* cx, unsigned argc, Value* vp); //remove this line
      [[nodiscard]] static bool set_impl(JSContext* cx, const CallArgs&amp; args);
      [[nodiscard]] static bool delete_impl(JSContext* cx, const CallArgs&amp; args);
      [[nodiscard]] static bool delete_(JSContext* cx, unsigned argc, Value* vp);
      [[nodiscard]] static bool keys_impl(JSContext* cx, const CallArgs&amp; args);
      //...
  }
</code></pre>
                        </details>

                        <p>  The <code>std_Map_has</code> method should now be available in self-hosted JavaScript™.</p>
                        <h3 id="optimize-the-function">Optimize the function</h3>
                        <p>  With <code>has</code> now exposed to self-hosted code, alter your implementation to use <code>std_Map_has</code> instead of a <code>for-of</code> loop
                            and <code>SameValueZero</code>.</p>
                        <details>
                            <summary>Solution</summary>

                            <pre><code class="language-js">
  function MapUpsert(key, value) {
    var M = this;

    if (!IsObject(M) || (M = GuardToMapObject(M)) === null) {
        return callFunction(
            CallMapMethodIfWrapped,
            this,
            key,
            value,
            &quot;MapUpsert&quot;
        );
    }

    if (callFunction(std_Map_has, M, key)) {
      return callFunction(std_Map_get, M, key);
    }

    callFunction(std_Map_set, M, key, value);
      return value;
  }
</code></pre>
                        </details>
                    </div>
                </section>

                <section class="collapsible" id="testing">
                    <h2>Testing with Test262</h2>
                    <div class="content-body">
                        <h3 id="writing-tests-for-test262">Writing tests for <a href="https://github.com/tc39/test262" target="_blank">Test262</a></h3>
                        <p>   When it comes to testing implementations, there are some guidelines to follow.
                            The official guidelines state that an acceptable test in Test262 is the following:</p>
                        <pre><code>Any test that exercises observable grammar or semantics, originating with citable,
ormative text in the latest draft of the ECMAScript® Language Specification,
the ECMAScript® Internationalization API Specification, the The JSON Data Interchange Syntax,
a Stage 3 proposal or a Pull Request which makes a normative change to any of those specifications.
</code></pre>
                        <p>   The key point for this, is that we can write tests for any observable grammar or semantic from our specification.</p>
                        <p>   First we need to identify the so-called testable lines in our specification.
                            One way to think about it, is when the behaviour of the specification is observable to the user, it is testable.</p>
                        <p>   An example of easily testable line in our specification is:
                            <code>2. Perform ? RequireInternalSlot(M, [[MapData]])</code></p>
                        <p>   Recall that this line, among other things, checks if <code>this</code> is an Object, therefore we can test it by trying it on non-objects.
                            Primitive types in JavaScript™ are not considered objects.
                            So an example of the tests you can write for this, could look like this:</p>
                        <pre><code class="language-js">var m = new Map();

assert.throws(TypeError, function () {
    m.upsert.call(false, 1, 1);
});
</code></pre>
                        <p>   The <code>assert</code> is part of the Test262 suite, here we assert that a TypeError is thrown.</p>
                        <p>   You can find the rest of the functions for assert <a href="https://github.com/tc39/test262/blob/main/CONTRIBUTING.md#test-environment" target="_blank">here</a>.</p>
                        <h3 id="more-than-just-testing">More than just testing</h3>
                        <p>   Additional to the tests, there is a strict guide for documentation for the test.</p>
                        <p>   You start the test by declaring the copyright, here you just fill in the year and your name:</p>
                        <pre><code>// Copyright (C) *Year *Name. All rights reserved.
// This code is governed by the BSD license found in the LICENSE file.
</code></pre>
                        <p>   The rest of the information is enclosed in a YAML string and has specified values to simplify parsing.
                            All the info is inside the YAML tags <code>/*---</code> and <code>---*/</code>.</p>
                        <p>   We start with the required key <code>esid</code>, which is the ECMAScript® identifier.
                            This doesn&#39;t apply to us yet, as the proposal hasn&#39;t gotten one, therefore we will use <code>pending</code>.</p>
                        <pre><code>esid: pending
</code></pre>
                        <p>   Next comes the description which is the other required key.
                            The description should be short and on one line regarding the purpose of this testcase.
                            In our case, it will look something like: </p>
                        <pre><code>description: &gt;
     Throws a TypeError if &#39;this&#39; is not an object
</code></pre>
                        <p>   Although not required, we should fill out the <code>info</code> key as well.
                            Some points that are beneficial here are:
                            - What does the method look like?
                            - Which line of code are we testing?</p>
                        <pre><code>info: |
     Map.upsert( key , value )

     1. Let M be the this value
     2. Perform ? RequireInternalSlot(M, [[MapData]])
     ...
</code></pre>
                        <p>   There are many other keys we can look at, but if you want to learn more about them, check out this <a href="https://github.com/tc39/test262/blob/main/CONTRIBUTING.md#frontmatter" target="_blank">link.</a></p>
                        <p>   Our full test should now look something like this:</p>
                        <pre><code class="language-js">// Copyright (C) 2024 Sune Eriksson Lianes. All rights reserved.
// This code is governed by the BSD license found in the LICENSE file.
/*---
esid: pending
description: &gt;
    Throws a TypeError if `this` is not an Object.
info: |
    Map.upsert ( key, value )

    1. Let M be the this value
    2. Perform ? RequireInternalSlot(M, [[MapData]])
    ...
---*/
var m = new Map();

assert.throws(TypeError, function () {
    m.upsert.call(false, 1, 1);
});
</code></pre>
                        <h3 id="fill-in-test-cases">Fill in test cases</h3>
                        <p>   We can now fill in with other test cases (non-objects):</p>
                        <pre><code class="language-js">// Copyright (C) 2024 Sune Eriksson Lianes. All rights reserved.
// This code is governed by the BSD license found in the LICENSE file.
/*---
esid: pending
description: &gt;
    Throws a TypeError if `this` is not an Object.
info: |
    Map.upsert ( key, value )

    1. Let M be the this value
    2. Perform ? RequireInternalSlot(M, [[MapData]])
    ...
features: [Symbol]
---*/
var m = new Map();

assert.throws(TypeError, function () {
    m.upsert.call(false, 1, 1);
});

assert.throws(TypeError, function () {
    m.upsert.call(1, 1, 1);
});

assert.throws(TypeError, function () {
    m.upsert.call(&quot;&quot;, 1, 1);
});

assert.throws(TypeError, function () {
    m.upsert.call(undefined, 1, 1);
});

assert.throws(TypeError, function () {
    m.upsert.call(null, 1, 1);
});

assert.throws(TypeError, function () {
    m.upsert.call(Symbol(), 1, 1);
});
</code></pre>
                        <p>   You can take a look at other tests written in the test262 folder or try to write some tests yourself.</p>
                        <h3 id="running-tests-in-spidermonkey">Running tests in SpiderMonkey</h3>
                        <p>   To add the test you simply create the file in <code>mozilla-unified/js/src/tests/test262/built-ins/Map/</code>.
                            Preferably creating a folder for the proposal as well.</p>
                        <p>   When this is done, you can run the tests with <code>./mach jstests built-ins/Map</code>, or be even more specific if you have created a folder.</p>
                        <p>   You will then see something like this, depending on how many tests are run:</p>
                        <pre><code class="language-sh">[1|0|0|0]  12% =====&gt;
[2|0|0|0]  25% ============&gt;
[3|0|0|0]  37% ===================&gt;
[4|0|0|0]  50% ==========================&gt;
[5|0|0|0]  62% =================================&gt;
[6|0|0|0]  75% ========================================&gt;
[7|0|0|0]  87% ===============================================&gt;
[8|0|0|0] 100% ======================================================
[8|0|0|0] 100% ======================================================&gt;|
0.4s
</code></pre>
                        <p>   A general tip for testing is looking at how similar lines are tested in other implementations.</p>

                    </div>
                </section>
            </main>

            <footer>
                <p>&copy; 2024 - Tutorial on Implementing Map.prototype.upsert</p>
            </footer>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        // Initialize highlight.js
        hljs.highlightAll();
    </script>
    <!-- Script to enable collapsible sections -->
    <script>
        document.querySelectorAll('.collapsible').forEach(section => {
            section.querySelector('h2').addEventListener('click', () => {
                section.querySelector('.content-body').classList.toggle('hidden');
            });
        });
    </script>

    <!-- Script for tabs -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Select all tab buttons and contents
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            // Function to show the selected tab
            function openTab(tabId) {
                // Hide all tab content
                tabContents.forEach(content => content.classList.remove('active'));

                // Remove 'active' class from all buttons
                tabButtons.forEach(button => button.classList.remove('active'));

                // Show the clicked tab's content and activate the button
                document.getElementById(tabId).classList.add('active');
                document.querySelector(`.tab-button[data-tab="${tabId}"]`).classList.add('active');
            }

            // Attach event listeners to all tab buttons
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');
                    openTab(tabId);
                });
            });

            // Initialize by showing the first tab by default
            openTab(tabButtons[0].getAttribute('data-tab'));
        });

    </script>
</body>
</html>
